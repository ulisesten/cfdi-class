// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CAT_CFDI_HXX
#define CAT_CFDI_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace sitio_internet
{
  namespace cfd
  {
    namespace catalogos
    {
      class c_FormaPago;
      class c_Moneda;
      class c_TipoDeComprobante;
      class c_MetodoPago;
      class c_CodigoPostal;
      class c_TipoRelacion;
      class c_RegimenFiscal;
      class c_Pais;
      class c_UsoCFDI;
      class c_ClaveProdServ;
      class c_ClaveUnidad;
      class c_Impuesto;
      class c_TipoFactor;
      class c_Estado;
      class c_Colonia;
      class c_Localidad;
      class c_Municipio;
    }
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace sitio_internet
{
  namespace cfd
  {
    namespace catalogos
    {
      class c_FormaPago: public ::xml_schema::string
      {
        public:
        enum value
        {
          cxx_01,
          cxx_02,
          cxx_03,
          cxx_04,
          cxx_05,
          cxx_06,
          cxx_08,
          cxx_12,
          cxx_13,
          cxx_14,
          cxx_15,
          cxx_17,
          cxx_23,
          cxx_24,
          cxx_25,
          cxx_26,
          cxx_27,
          cxx_28,
          cxx_29,
          cxx_30,
          cxx_31,
          cxx_99
        };

        c_FormaPago (value v);

        c_FormaPago (const char* v);

        c_FormaPago (const ::std::string& v);

        c_FormaPago (const ::xml_schema::string& v);

        c_FormaPago (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        c_FormaPago (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        c_FormaPago (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        c_FormaPago (const c_FormaPago& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        virtual c_FormaPago*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_FormaPago&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_FormaPago_convert ();
        }

        protected:
        value
        _xsd_c_FormaPago_convert () const;

        public:
        static const char* const _xsd_c_FormaPago_literals_[22];
        static const value _xsd_c_FormaPago_indexes_[22];
      };

      class c_Moneda: public ::xml_schema::string
      {
        public:
        enum value
        {
          AED,
          AFN,
          ALL,
          AMD,
          ANG,
          AOA,
          ARS,
          AUD,
          AWG,
          AZN,
          BAM,
          BBD,
          BDT,
          BGN,
          BHD,
          BIF,
          BMD,
          BND,
          BOB,
          BOV,
          BRL,
          BSD,
          BTN,
          BWP,
          BYR,
          BZD,
          CAD,
          CDF,
          CHE,
          CHF,
          CHW,
          CLF,
          CLP,
          CNY,
          COP,
          COU,
          CRC,
          CUC,
          CUP,
          CVE,
          CZK,
          DJF,
          DKK,
          DOP,
          DZD,
          EGP,
          ERN,
          ETB,
          EUR,
          FJD,
          FKP,
          GBP,
          GEL,
          GHS,
          GIP,
          GMD,
          GNF,
          GTQ,
          GYD,
          HKD,
          HNL,
          HRK,
          HTG,
          HUF,
          IDR,
          ILS,
          INR,
          IQD,
          IRR,
          ISK,
          JMD,
          JOD,
          JPY,
          KES,
          KGS,
          KHR,
          KMF,
          KPW,
          KRW,
          KWD,
          KYD,
          KZT,
          LAK,
          LBP,
          LKR,
          LRD,
          LSL,
          LYD,
          MAD,
          MDL,
          MGA,
          MKD,
          MMK,
          MNT,
          MOP,
          MRO,
          MUR,
          MVR,
          MWK,
          MXN,
          MXV,
          MYR,
          MZN,
          NAD,
          NGN,
          NIO,
          NOK,
          NPR,
          NZD,
          OMR,
          PAB,
          PEN,
          PGK,
          PHP,
          PKR,
          PLN,
          PYG,
          QAR,
          RON,
          RSD,
          RUB,
          RWF,
          SAR,
          SBD,
          SCR,
          SDG,
          SEK,
          SGD,
          SHP,
          SLL,
          SOS,
          SRD,
          SSP,
          STD,
          SVC,
          SYP,
          SZL,
          THB,
          TJS,
          TMT,
          TND,
          TOP,
          TRY,
          TTD,
          TWD,
          TZS,
          UAH,
          UGX,
          USD,
          USN,
          UYI,
          UYU,
          UZS,
          VEF,
          VND,
          VUV,
          WST,
          XAF,
          XAG,
          XAU,
          XBA,
          XBB,
          XBC,
          XBD,
          XCD,
          XDR,
          XOF,
          XPD,
          XPF,
          XPT,
          XSU,
          XTS,
          XUA,
          XXX,
          YER,
          ZAR,
          ZMW,
          ZWL
        };

        c_Moneda (value v);

        c_Moneda (const char* v);

        c_Moneda (const ::std::string& v);

        c_Moneda (const ::xml_schema::string& v);

        c_Moneda (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        c_Moneda (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        c_Moneda (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        c_Moneda (const c_Moneda& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        virtual c_Moneda*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_Moneda&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_Moneda_convert ();
        }

        protected:
        value
        _xsd_c_Moneda_convert () const;

        public:
        static const char* const _xsd_c_Moneda_literals_[178];
        static const value _xsd_c_Moneda_indexes_[178];
      };

      class c_TipoDeComprobante: public ::xml_schema::string
      {
        public:
        enum value
        {
          I,
          E,
          T,
          N,
          P
        };

        c_TipoDeComprobante (value v);

        c_TipoDeComprobante (const char* v);

        c_TipoDeComprobante (const ::std::string& v);

        c_TipoDeComprobante (const ::xml_schema::string& v);

        c_TipoDeComprobante (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        c_TipoDeComprobante (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        c_TipoDeComprobante (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        c_TipoDeComprobante (const c_TipoDeComprobante& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        virtual c_TipoDeComprobante*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_TipoDeComprobante&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_TipoDeComprobante_convert ();
        }

        protected:
        value
        _xsd_c_TipoDeComprobante_convert () const;

        public:
        static const char* const _xsd_c_TipoDeComprobante_literals_[5];
        static const value _xsd_c_TipoDeComprobante_indexes_[5];
      };

      class c_MetodoPago: public ::xml_schema::string
      {
        public:
        enum value
        {
          PUE,
          PPD
        };

        c_MetodoPago (value v);

        c_MetodoPago (const char* v);

        c_MetodoPago (const ::std::string& v);

        c_MetodoPago (const ::xml_schema::string& v);

        c_MetodoPago (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        c_MetodoPago (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        c_MetodoPago (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        c_MetodoPago (const c_MetodoPago& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual c_MetodoPago*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_MetodoPago&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_MetodoPago_convert ();
        }

        protected:
        value
        _xsd_c_MetodoPago_convert () const;

        public:
        static const char* const _xsd_c_MetodoPago_literals_[2];
        static const value _xsd_c_MetodoPago_indexes_[2];
      };

      class c_CodigoPostal: public ::xml_schema::string
      {
        public:
        enum value
        {};

        c_CodigoPostal (value v);

        c_CodigoPostal (const char* v);

        c_CodigoPostal (const ::std::string& v);

        c_CodigoPostal (const ::xml_schema::string& v);

        c_CodigoPostal (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        c_CodigoPostal (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        c_CodigoPostal (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        c_CodigoPostal (const c_CodigoPostal& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        virtual c_CodigoPostal*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_CodigoPostal&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_CodigoPostal_convert ();
        }

        protected:
        value
        _xsd_c_CodigoPostal_convert () const;

        public:
        static const char* const _xsd_c_CodigoPostal_literals_[95777];
        static const value _xsd_c_CodigoPostal_indexes_[95777];
      };

      class c_TipoRelacion: public ::xml_schema::string
      {
        public:
        enum value
        {
          cxx_01,
          cxx_02,
          cxx_03,
          cxx_04,
          cxx_05,
          cxx_06,
          cxx_07,
          cxx_08,
          cxx_09
        };

        c_TipoRelacion (value v);

        c_TipoRelacion (const char* v);

        c_TipoRelacion (const ::std::string& v);

        c_TipoRelacion (const ::xml_schema::string& v);

        c_TipoRelacion (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        c_TipoRelacion (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        c_TipoRelacion (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        c_TipoRelacion (const c_TipoRelacion& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        virtual c_TipoRelacion*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_TipoRelacion&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_TipoRelacion_convert ();
        }

        protected:
        value
        _xsd_c_TipoRelacion_convert () const;

        public:
        static const char* const _xsd_c_TipoRelacion_literals_[9];
        static const value _xsd_c_TipoRelacion_indexes_[9];
      };

      class c_RegimenFiscal: public ::xml_schema::string
      {
        public:
        enum value
        {
          cxx_601,
          cxx_603,
          cxx_605,
          cxx_606,
          cxx_608,
          cxx_609,
          cxx_610,
          cxx_611,
          cxx_612,
          cxx_614,
          cxx_616,
          cxx_620,
          cxx_621,
          cxx_622,
          cxx_623,
          cxx_624,
          cxx_628,
          cxx_607,
          cxx_629,
          cxx_630,
          cxx_615,
          cxx_625
        };

        c_RegimenFiscal (value v);

        c_RegimenFiscal (const char* v);

        c_RegimenFiscal (const ::std::string& v);

        c_RegimenFiscal (const ::xml_schema::string& v);

        c_RegimenFiscal (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        c_RegimenFiscal (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        c_RegimenFiscal (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        c_RegimenFiscal (const c_RegimenFiscal& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual c_RegimenFiscal*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_RegimenFiscal&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_RegimenFiscal_convert ();
        }

        protected:
        value
        _xsd_c_RegimenFiscal_convert () const;

        public:
        static const char* const _xsd_c_RegimenFiscal_literals_[22];
        static const value _xsd_c_RegimenFiscal_indexes_[22];
      };

      class c_Pais: public ::xml_schema::string
      {
        public:
        enum value
        {
          AFG,
          ALA,
          ALB,
          DEU,
          AND,
          AGO,
          AIA,
          ATA,
          ATG,
          SAU,
          DZA,
          ARG,
          ARM,
          ABW,
          AUS,
          AUT,
          AZE,
          BHS,
          BGD,
          BRB,
          BHR,
          BEL,
          BLZ,
          BEN,
          BMU,
          BLR,
          MMR,
          BOL,
          BIH,
          BWA,
          BRA,
          BRN,
          BGR,
          BFA,
          BDI,
          BTN,
          CPV,
          KHM,
          CMR,
          CAN,
          QAT,
          BES,
          TCD,
          CHL,
          CHN,
          CYP,
          COL,
          COM,
          PRK,
          KOR,
          CIV,
          CRI,
          HRV,
          CUB,
          CUW,
          DNK,
          DMA,
          ECU,
          EGY,
          SLV,
          ARE,
          ERI,
          SVK,
          SVN,
          ESP,
          USA,
          EST,
          ETH,
          PHL,
          FIN,
          FJI,
          FRA,
          GAB,
          GMB,
          GEO,
          GHA,
          GIB,
          GRD,
          GRC,
          GRL,
          GLP,
          GUM,
          GTM,
          GUF,
          GGY,
          GIN,
          GNB,
          GNQ,
          GUY,
          HTI,
          HND,
          HKG,
          HUN,
          IND,
          IDN,
          IRQ,
          IRN,
          IRL,
          BVT,
          IMN,
          CXR,
          NFK,
          ISL,
          CYM,
          CCK,
          COK,
          FRO,
          SGS,
          HMD,
          FLK,
          MNP,
          MHL,
          PCN,
          SLB,
          TCA,
          UMI,
          VGB,
          VIR,
          ISR,
          ITA,
          JAM,
          JPN,
          JEY,
          JOR,
          KAZ,
          KEN,
          KGZ,
          KIR,
          KWT,
          LAO,
          LSO,
          LVA,
          LBN,
          LBR,
          LBY,
          LIE,
          LTU,
          LUX,
          MAC,
          MDG,
          MYS,
          MWI,
          MDV,
          MLI,
          MLT,
          MAR,
          MTQ,
          MUS,
          MRT,
          MYT,
          MEX,
          FSM,
          MDA,
          MCO,
          MNG,
          MNE,
          MSR,
          MOZ,
          NAM,
          NRU,
          NPL,
          NIC,
          NER,
          NGA,
          NIU,
          NOR,
          NCL,
          NZL,
          OMN,
          NLD,
          PAK,
          PLW,
          PSE,
          PAN,
          PNG,
          PRY,
          PER,
          PYF,
          POL,
          PRT,
          PRI,
          GBR,
          CAF,
          CZE,
          MKD,
          COG,
          COD,
          DOM,
          REU,
          RWA,
          ROU,
          RUS,
          ESH,
          WSM,
          ASM,
          BLM,
          KNA,
          SMR,
          MAF,
          SPM,
          VCT,
          SHN,
          LCA,
          STP,
          SEN,
          SRB,
          SYC,
          SLE,
          SGP,
          SXM,
          SYR,
          SOM,
          LKA,
          SWZ,
          ZAF,
          SDN,
          SSD,
          SWE,
          CHE,
          SUR,
          SJM,
          THA,
          TWN,
          TZA,
          TJK,
          IOT,
          ATF,
          TLS,
          TGO,
          TKL,
          TON,
          TTO,
          TUN,
          TKM,
          TUR,
          TUV,
          UKR,
          UGA,
          URY,
          UZB,
          VUT,
          VAT,
          VEN,
          VNM,
          WLF,
          YEM,
          DJI,
          ZMB,
          ZWE,
          ZZZ
        };

        c_Pais (value v);

        c_Pais (const char* v);

        c_Pais (const ::std::string& v);

        c_Pais (const ::xml_schema::string& v);

        c_Pais (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

        c_Pais (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

        c_Pais (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

        c_Pais (const c_Pais& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

        virtual c_Pais*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_Pais&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_Pais_convert ();
        }

        protected:
        value
        _xsd_c_Pais_convert () const;

        public:
        static const char* const _xsd_c_Pais_literals_[250];
        static const value _xsd_c_Pais_indexes_[250];
      };

      class c_UsoCFDI: public ::xml_schema::string
      {
        public:
        enum value
        {
          G01,
          G02,
          G03,
          I01,
          I02,
          I03,
          I04,
          I05,
          I06,
          I07,
          I08,
          D01,
          D02,
          D03,
          D04,
          D05,
          D06,
          D07,
          D08,
          D09,
          D10,
          P01
        };

        c_UsoCFDI (value v);

        c_UsoCFDI (const char* v);

        c_UsoCFDI (const ::std::string& v);

        c_UsoCFDI (const ::xml_schema::string& v);

        c_UsoCFDI (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        c_UsoCFDI (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        c_UsoCFDI (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        c_UsoCFDI (const c_UsoCFDI& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        virtual c_UsoCFDI*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_UsoCFDI&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_UsoCFDI_convert ();
        }

        protected:
        value
        _xsd_c_UsoCFDI_convert () const;

        public:
        static const char* const _xsd_c_UsoCFDI_literals_[22];
        static const value _xsd_c_UsoCFDI_indexes_[22];
      };

      class c_ClaveProdServ: public ::xml_schema::string
      {
        public:
        enum value
        {
            cxx_01010101
        };

        c_ClaveProdServ (value v);

        c_ClaveProdServ (const char* v);

        c_ClaveProdServ (const ::std::string& v);

        c_ClaveProdServ (const ::xml_schema::string& v);

        c_ClaveProdServ (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        c_ClaveProdServ (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        c_ClaveProdServ (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        c_ClaveProdServ (const c_ClaveProdServ& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual c_ClaveProdServ*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_ClaveProdServ&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_ClaveProdServ_convert ();
        }

        protected:
        value
        _xsd_c_ClaveProdServ_convert () const;

        public:
        static const char* const _xsd_c_ClaveProdServ_literals_[52746];
        static const value _xsd_c_ClaveProdServ_indexes_[52746];
      };

      class c_ClaveUnidad: public ::xml_schema::string
      {
        public:
        enum value
        {};
        c_ClaveUnidad (value v);

        c_ClaveUnidad (const char* v);

        c_ClaveUnidad (const ::std::string& v);

        c_ClaveUnidad (const ::xml_schema::string& v);

        c_ClaveUnidad (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        c_ClaveUnidad (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        c_ClaveUnidad (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        c_ClaveUnidad (const c_ClaveUnidad& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        virtual c_ClaveUnidad*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_ClaveUnidad&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_ClaveUnidad_convert ();
        }

        protected:
        value
        _xsd_c_ClaveUnidad_convert () const;

        public:
        static const char* const _xsd_c_ClaveUnidad_literals_[2418];
        static const value _xsd_c_ClaveUnidad_indexes_[2418];
      };

      class c_Impuesto: public ::xml_schema::string
      {
        public:
        enum value
        {
          cxx_001,
          cxx_002,
          cxx_003
        };

        c_Impuesto (value v);

        c_Impuesto (const char* v);

        c_Impuesto (const ::std::string& v);

        c_Impuesto (const ::xml_schema::string& v);

        c_Impuesto (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        c_Impuesto (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        c_Impuesto (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        c_Impuesto (const c_Impuesto& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual c_Impuesto*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_Impuesto&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_Impuesto_convert ();
        }

        protected:
        value
        _xsd_c_Impuesto_convert () const;

        public:
        static const char* const _xsd_c_Impuesto_literals_[3];
        static const value _xsd_c_Impuesto_indexes_[3];
      };

      class c_TipoFactor: public ::xml_schema::string
      {
        public:
        enum value
        {
          Tasa,
          Cuota,
          Exento
        };

        c_TipoFactor (value v);

        c_TipoFactor (const char* v);

        c_TipoFactor (const ::std::string& v);

        c_TipoFactor (const ::xml_schema::string& v);

        c_TipoFactor (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        c_TipoFactor (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        c_TipoFactor (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        c_TipoFactor (const c_TipoFactor& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual c_TipoFactor*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_TipoFactor&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_TipoFactor_convert ();
        }

        protected:
        value
        _xsd_c_TipoFactor_convert () const;

        public:
        static const char* const _xsd_c_TipoFactor_literals_[3];
        static const value _xsd_c_TipoFactor_indexes_[3];
      };

      class c_Estado: public ::xml_schema::string
      {
        public:
        enum value
        {
          AGU,
          BCN,
          BCS,
          CAM,
          CHP,
          CHH,
          COA,
          COL,
          DIF,
          DUR,
          GUA,
          GRO,
          HID,
          JAL,
          MEX,
          MIC,
          MOR,
          NAY,
          NLE,
          OAX,
          PUE,
          QUE,
          ROO,
          SLP,
          SIN,
          SON,
          TAB,
          TAM,
          TLA,
          VER,
          YUC,
          ZAC,
          AL,
          AK,
          AZ,
          AR,
          CA,
          NC,
          SC,
          CO,
          CT,
          ND,
          SD,
          DE,
          FL,
          GA,
          HI,
          ID,
          IL,
          IN,
          IA,
          KS,
          KY,
          LA,
          ME,
          MD,
          MA,
          MI,
          MN,
          MS,
          MO,
          MT,
          NE,
          NV,
          NJ,
          NY,
          NH,
          NM,
          OH,
          OK,
          OR,
          PA,
          RI,
          TN,
          TX,
          UT,
          VT,
          VA,
          WV,
          WA,
          WI,
          WY,
          ON,
          QC,
          NS,
          NB,
          MB,
          BC,
          PE,
          SK,
          AB,
          NL,
          NT,
          YT,
          UN
        };

        c_Estado (value v);

        c_Estado (const char* v);

        c_Estado (const ::std::string& v);

        c_Estado (const ::xml_schema::string& v);

        c_Estado (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        c_Estado (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        c_Estado (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        c_Estado (const c_Estado& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        virtual c_Estado*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_Estado&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_Estado_convert ();
        }

        protected:
        value
        _xsd_c_Estado_convert () const;

        public:
        static const char* const _xsd_c_Estado_literals_[95];
        static const value _xsd_c_Estado_indexes_[95];
      };

      class c_Colonia: public ::xml_schema::string
      {
        public:
        enum value
        {};

        c_Colonia (value v);

        c_Colonia (const char* v);

        c_Colonia (const ::std::string& v);

        c_Colonia (const ::xml_schema::string& v);

        c_Colonia (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        c_Colonia (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        c_Colonia (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        c_Colonia (const c_Colonia& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

        virtual c_Colonia*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_Colonia&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_Colonia_convert ();
        }

        protected:
        value
        _xsd_c_Colonia_convert () const;

        public:
        static const char* const _xsd_c_Colonia_literals_[9999];
        static const value _xsd_c_Colonia_indexes_[9999];
      };

      class c_Localidad: public ::xml_schema::string
      {
        public:
        enum value
        {};

        c_Localidad (value v);

        c_Localidad (const char* v);

        c_Localidad (const ::std::string& v);

        c_Localidad (const ::xml_schema::string& v);

        c_Localidad (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        c_Localidad (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        c_Localidad (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        c_Localidad (const c_Localidad& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        virtual c_Localidad*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_Localidad&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_Localidad_convert ();
        }

        protected:
        value
        _xsd_c_Localidad_convert () const;

        public:
        static const char* const _xsd_c_Localidad_literals_[66];
        static const value _xsd_c_Localidad_indexes_[66];
      };

      class c_Municipio: public ::xml_schema::string
      {
        public:
        enum value
        {};

        c_Municipio (value v);

        c_Municipio (const char* v);

        c_Municipio (const ::std::string& v);

        c_Municipio (const ::xml_schema::string& v);

        c_Municipio (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        c_Municipio (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        c_Municipio (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        c_Municipio (const c_Municipio& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        virtual c_Municipio*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        c_Municipio&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_c_Municipio_convert ();
        }

        protected:
        value
        _xsd_c_Municipio_convert () const;

        public:
        static const char* const _xsd_c_Municipio_literals_[570];
        static const value _xsd_c_Municipio_indexes_[570];
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace sitio_internet
{
  namespace cfd
  {
    namespace catalogos
    {
    }
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace sitio_internet
{
  namespace cfd
  {
    namespace catalogos
    {
      void
      operator<< (::xercesc::DOMElement&, const c_FormaPago&);

      void
      operator<< (::xercesc::DOMAttr&, const c_FormaPago&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_FormaPago&);

      void
      operator<< (::xercesc::DOMElement&, const c_Moneda&);

      void
      operator<< (::xercesc::DOMAttr&, const c_Moneda&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_Moneda&);

      void
      operator<< (::xercesc::DOMElement&, const c_TipoDeComprobante&);

      void
      operator<< (::xercesc::DOMAttr&, const c_TipoDeComprobante&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_TipoDeComprobante&);

      void
      operator<< (::xercesc::DOMElement&, const c_MetodoPago&);

      void
      operator<< (::xercesc::DOMAttr&, const c_MetodoPago&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_MetodoPago&);

      void
      operator<< (::xercesc::DOMElement&, const c_CodigoPostal&);

      void
      operator<< (::xercesc::DOMAttr&, const c_CodigoPostal&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_CodigoPostal&);

      void
      operator<< (::xercesc::DOMElement&, const c_TipoRelacion&);

      void
      operator<< (::xercesc::DOMAttr&, const c_TipoRelacion&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_TipoRelacion&);

      void
      operator<< (::xercesc::DOMElement&, const c_RegimenFiscal&);

      void
      operator<< (::xercesc::DOMAttr&, const c_RegimenFiscal&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_RegimenFiscal&);

      void
      operator<< (::xercesc::DOMElement&, const c_Pais&);

      void
      operator<< (::xercesc::DOMAttr&, const c_Pais&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_Pais&);

      void
      operator<< (::xercesc::DOMElement&, const c_UsoCFDI&);

      void
      operator<< (::xercesc::DOMAttr&, const c_UsoCFDI&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_UsoCFDI&);

      void
      operator<< (::xercesc::DOMElement&, const c_ClaveProdServ&);

      void
      operator<< (::xercesc::DOMAttr&, const c_ClaveProdServ&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_ClaveProdServ&);

      void
      operator<< (::xercesc::DOMElement&, const c_ClaveUnidad&);

      void
      operator<< (::xercesc::DOMAttr&, const c_ClaveUnidad&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_ClaveUnidad&);

      void
      operator<< (::xercesc::DOMElement&, const c_Impuesto&);

      void
      operator<< (::xercesc::DOMAttr&, const c_Impuesto&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_Impuesto&);

      void
      operator<< (::xercesc::DOMElement&, const c_TipoFactor&);

      void
      operator<< (::xercesc::DOMAttr&, const c_TipoFactor&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_TipoFactor&);

      void
      operator<< (::xercesc::DOMElement&, const c_Estado&);

      void
      operator<< (::xercesc::DOMAttr&, const c_Estado&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_Estado&);

      void
      operator<< (::xercesc::DOMElement&, const c_Colonia&);

      void
      operator<< (::xercesc::DOMAttr&, const c_Colonia&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_Colonia&);

      void
      operator<< (::xercesc::DOMElement&, const c_Localidad&);

      void
      operator<< (::xercesc::DOMAttr&, const c_Localidad&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_Localidad&);

      void
      operator<< (::xercesc::DOMElement&, const c_Municipio&);

      void
      operator<< (::xercesc::DOMAttr&, const c_Municipio&);

      void
      operator<< (::xml_schema::list_stream&,
                  const c_Municipio&);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CAT_CFDI_HXX
